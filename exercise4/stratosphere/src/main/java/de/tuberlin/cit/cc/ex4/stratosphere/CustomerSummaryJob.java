package de.tuberlin.cit.cc.ex4.stratosphere;

import java.io.File;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import de.tuberlin.cit.cc.ex4.stratosphere.format.CustomerSummaryOutputFormat;
import de.tuberlin.cit.cc.ex4.stratosphere.format.CustomerTableInputFormat;
import de.tuberlin.cit.cc.ex4.stratosphere.format.LineItemTableInputFormat;
import de.tuberlin.cit.cc.ex4.stratosphere.format.OrderTableInputFormat;
import de.tuberlin.cit.cc.ex4.stratosphere.stubs.CustomerAndOrderSummarizer;
import de.tuberlin.cit.cc.ex4.stratosphere.stubs.LineItemFilter;
import de.tuberlin.cit.cc.ex4.stratosphere.stubs.OrderAndLineItemSummarizer;
import de.tuberlin.cit.cc.ex4.stratosphere.types.Customer;
import de.tuberlin.cit.cc.ex4.stratosphere.types.CustomerSummary;
import de.tuberlin.cit.cc.ex4.stratosphere.types.LineItem;
import de.tuberlin.cit.cc.ex4.stratosphere.types.LineItemSummary;
import de.tuberlin.cit.cc.ex4.stratosphere.types.Order;
import de.tuberlin.cit.cc.ex4.stratosphere.types.OrderSummary;
import eu.stratosphere.pact.common.contract.FileDataSinkContract;
import eu.stratosphere.pact.common.contract.FileDataSourceContract;
import eu.stratosphere.pact.common.contract.MatchContract;
import eu.stratosphere.pact.common.contract.OutputContract.SameKey;
import eu.stratosphere.pact.common.contract.OutputContract.UniqueKey;
import eu.stratosphere.pact.common.contract.ReduceContract;
import eu.stratosphere.pact.common.plan.Plan;
import eu.stratosphere.pact.common.plan.PlanAssembler;
import eu.stratosphere.pact.common.plan.PlanAssemblerDescription;
import eu.stratosphere.pact.common.type.base.PactInteger;
import eu.stratosphere.pact.common.type.base.PactNull;

public class CustomerSummaryJob implements PlanAssembler,
    PlanAssemblerDescription {

  private static final Log LOG = LogFactory.getLog(CustomerSummaryJob.class);

  /**
   * {@inheritDoc}
   */
  @Override
  public Plan getPlan(String... args) {

    int noSubTasks = 1;
    int minOrderVolume = (args.length > 0 ? Integer.parseInt(args[0]) : 0);
    String inputPath = (args.length > 1 ? verifyEndsWithFileSeparator(args[1])
        : null);
    String outputPath = (args.length > 2 ? verifyEndsWithFileSeparator(args[2])
        : null);

    if (inputPath == null) {
      throw new IllegalArgumentException(
          "Please provide path to the files generated by dbgen.");
    }
    LOG.info("Reading input from '" + inputPath + "'");
    if (outputPath == null) {
      outputPath = inputPath;
      LOG.warn("No output path provided. Reusing input path for output.");
    }
    LOG.info("Writing output to '" + outputPath + "'");

    final String lineItemFile = inputPath + "lineitem.tbl";
    final String customersFile = inputPath + "customer.tbl";
    final String ordersFile = inputPath + "orders.tbl";
    final String outputFile = outputPath + "customerinfo.tbl";

    FileDataSourceContract<PactInteger, LineItem> lineItemSource = new FileDataSourceContract<PactInteger, LineItem>(
        LineItemTableInputFormat.class, lineItemFile, "LineItem Source");
    lineItemSource.setDegreeOfParallelism(noSubTasks);

    ReduceContract<PactInteger, LineItem, PactInteger, LineItemSummary> lineItemFilter = new ReduceContract<PactInteger, LineItem, PactInteger, LineItemSummary>(
        LineItemFilter.class, "LineItem Filter");
    lineItemFilter.setDegreeOfParallelism(noSubTasks);
    // line items are grouped but keys not changed
    lineItemFilter.setOutputContract(SameKey.class);
    lineItemFilter.getParameters().setLong(
        LineItemFilter.CONFIG_MIN_ORDER_VOLUME, minOrderVolume);

    FileDataSourceContract<PactInteger, Order> orderSource = new FileDataSourceContract<PactInteger, Order>(
        OrderTableInputFormat.class, ordersFile, "Order Source");
    orderSource.setDegreeOfParallelism(noSubTasks);
    // dbgen generates unique input keys
    orderSource.setOutputContract(UniqueKey.class);

    MatchContract<PactInteger, Order, LineItemSummary, PactInteger, OrderSummary> orderAndLineItemMatcher = new MatchContract<PactInteger, Order, LineItemSummary, PactInteger, OrderSummary>(
        OrderAndLineItemSummarizer.class, "Order and LineItem Summarizer");
    orderAndLineItemMatcher.setDegreeOfParallelism(noSubTasks);

    FileDataSourceContract<PactInteger, Customer> customerSource = new FileDataSourceContract<PactInteger, Customer>(
        CustomerTableInputFormat.class, customersFile, "Customer Source");
    customerSource.setDegreeOfParallelism(noSubTasks);
    // dbgen generates unique input keys
    customerSource.setOutputContract(UniqueKey.class);

    MatchContract<PactInteger, Customer, OrderSummary, PactNull, CustomerSummary> customerAndOrderMatcher = new MatchContract<PactInteger, Customer, OrderSummary, PactNull, CustomerSummary>(
        CustomerAndOrderSummarizer.class, "Customer and Order Item Summarizer");
    customerAndOrderMatcher.setDegreeOfParallelism(noSubTasks);

    FileDataSinkContract<PactNull, CustomerSummary> out = new FileDataSinkContract<PactNull, CustomerSummary>(
        CustomerSummaryOutputFormat.class, outputFile, "Output");
    out.setDegreeOfParallelism(noSubTasks);

    out.setInput(customerAndOrderMatcher);
    customerAndOrderMatcher.setFirstInput(customerSource);
    customerAndOrderMatcher.setSecondInput(orderAndLineItemMatcher);
    orderAndLineItemMatcher.setFirstInput(orderSource);
    orderAndLineItemMatcher.setSecondInput(lineItemFilter);
    lineItemFilter.setInput(lineItemSource);

    return new Plan(out, "Customer Summary");
  }

  private String verifyEndsWithFileSeparator(String path) {
    if (!path.endsWith(File.separator)) {
      path += File.separator;
    }
    return path;
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public String getDescription() {
    return "[minOrderVolume:int] [pathToTplFiles:URI] [outputPath:URI]";
  }
}
